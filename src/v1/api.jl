export TransferOperator, 
    transferoperator, 
    TransferOperatorGenerator, 
    transopergenerator,
    GridBasedTransferOperator 

import CausalityToolsBase.BinningScheme

""" Supertype of all transfer operator estimators. """
abstract type TransferOperator end 

""" Supertype of all grid-based transfer operator estimators """
abstract type GridBasedTransferOperator <: TransferOperator end

"""
    TransferOperatorGenerator{E <: TransferOperator}(method::E, pts, init)

A transfer operator generator. Contains the partition information, 
the method for transition probability estimation, the input `pts` and 
`init`, which are things that can be pre-computed to speed up estimation 
process. 
"""
struct TransferOperatorGenerator{E <: TransferOperator, X, A}
    method::E # estimator with its input parameters
    pts::X    # the phase space / reconstruted state space points
    init::A   # pre-initialized things that speed up estimation process
end

"""
    transopergenerator(pts, method::TransferOperator) → to::TransferOperatorGenerator

Initialize a generator that creates transfer operators on demand, based on the given `method`.
This is efficient, because some things can be initialized and reused.

To approximate a transfer operator, call `to` as a function with the relevant arguments.

```julia
to = transopergenerator(x, SingleGrid(RectangularBinning(5)))
for i in 1:1000
    s = to()
    # do stuff with s and or x
    result[i] = stuff
end
```
"""
function transopergenerator end

"""
    transferoperator(pts, method::TransferOperator) → to::TransferOperatorApproximation
    transferoperator(pts, method::SingleGrid) → to::TransferOperatorApproximation
    transferoperator(pts, method::SimplexPoint; tol = 1e-8, randomsampling::Bool = false, n::Int = 100) → to::TransferOperatorApproximation
    transferoperator(pts, method::SimplexExact; tol::Real = 1e-8) → to::TransferOperatorApproximation

Create a transfer operator `to` from the phase/state space points `x` based on the given `method`.

Using the `SingleGrid` estimator will partition the state space into rectangular bins, while 
the `SimplexPoint` and `SimplexExact` estimators will triangulate the state space.

- If using any of the triangulation estimators, `Simplices` must be imported after `PerronFrobenius`.
- If using `SimplexPoint` and `randomsampling==true`, then each simplex is represented by a 
    point cloud uniformly distributed within each simplex. If `randomsampling==false`, then 
    an even simplex splitting routine is used to generate interior points. `n` is the 
    minimum number of sampling points (more points may be used if `randomsampling==false`, 
    because the number of points generated by the splitting routine is dictated by the dimension 
    and splitting factor).

## Examples

### Grid estimators

Use the `SingleGrid` estimator for long time series.

```julia 
n = 30000
x = [cos(2π*(t + sin(t)/30)) for t in 1:n] .+ 0.2rand(n)
y = [cos(2π*(t + sin(t)/10)) for t in 1:n] .+ 0.5rand(n)

τs = (2, 0, -2)
js = (2, 2, 1)
D = genembed([x, y], τs, js)

method = SingleGrid(RectangularBinning(5))
transferoperator(D, method)
```

### Triangulation estimators

Use the `SimplexExact` (slow) estimator or `SimplexPoint` (also slow, 
but faster than `SimplexExact`) estimator for very short time series.
For these estimators to be imported, you need to load `Simplices` *after*
loading `PerronFrobenius`.

```julia 
n = 30
x = [cos(2π*(t + sin(t)/30)) for t in 1:n] .+ 0.2rand(n)
y = [cos(2π*(t + sin(t)/10)) for t in 1:n] .+ 0.5rand(n)

τs = (2, 0, -2)
js = (2, 2, 1)
D = genembed([x, y], τs, js)

# Compute transition probabilities using approximate simplex intersections.
# Sample each simplex using at least `n = 300` points.
method = SimplexApprox()
transferoperator(D, method, n = 300)
```
"""
function transferoperator(pts, method::TransferOperator)
    to = transopergenerator(pts, method)
    to()
end
