include("potentially_intersecting_simplices.jl")
include("reshape_simplices.jl")
include("function_barriers.jl")

import ..AbstractTransferOperator
import StateSpaceReconstruction:
    DelaunayTriangulation,
    Simplex,
	point_contained
import Simplices: subsample_coeffs
import StaticArrays: Size
import Statistics: det
import InplaceOps: @!

#####################################
# Exports (don't export this estimator, the other one is more efficient)
#####################################
#export transferoperator_triangulation_approx




#####################################
# Constructors
#####################################


function transferoperator_triangulation_approxSlow(inv_pts;
                            n_sample_pts::Int = 200,
                            sample_randomly::Bool = false)

    # Triangulate all points but the last (we need the last point
    # for the forward projection of the simplices)
    DT = DelaunayTriangulation(inv_pts[1:(end - 1)])

    # Some constants used throughout the function
    n_simplices = length(DT)
    dim = length(DT[1]) - 1

    #=
    # Prepare memory-efficient representations of the simplices
    =#
    simplices = reshape_simplices(inv_pts[1:(end- 1)], DT)
    image_simplices = reshape_simplices(inv_pts[2:end], DT)

    #=
    Compute the convex expansions coefficients needed to generate points
    within a simplex. Also, update number of points if a shape-preserving
    simplex subdivision algorithm was used (in that case, we get a
    *minimum* of `n_sample_pts` set of coefficients.
    =#
    convex_coeffs = subsample_coeffs(dim, n_sample_pts, sample_randomly)
    n_coeffs::Int = size(convex_coeffs, 2)
    convex_coeffs = [convex_coeffs[:, i] for i = 1:n_coeffs]

    # Pre-allocated arrays (SizedArrays, for efficiency)
    pt          = Size(1, dim)(zeros(Float64, 1, dim))
    s_arr       = Size((dim+1)^2)(zeros(Float64, (dim+1)^2))
    signs       = Size(dim + 1)(zeros(Float64, dim + 1))

    # Re-arrange simplices so that look-up is a bit more efficient
    simplex_arrs = Vector{Array{Float64, 2}}(undef, n_simplices)
    imsimplex_arrs = Vector{Array{Float64, 2}}(undef, n_simplices)

    for i in 1:n_simplices
        simplex_arrs[i] = hcat(inv_pts[DT[i]]...,)
        imsimplex_arrs[i] = hcat(inv_pts[DT[i] .+ 1]...,)
    end

    # The Markov matrix
    M = zeros(Float64, n_simplices, n_simplices)

    for i in 1:n_simplices
        # Find the indices of the simplices who potentially intersect
        # with the image of simplex #i
        idxs = idxs_potentially_intersecting_simplices(inv_pts, DT, i)
        Sj = Vector{AbstractArray}(undef, length(idxs))
        get_simplices_at_inds!(Sj, idxs, simplices)

        # Generate points within the image of simplex #i and check
        # what fraction of those points fall into the simplices.
        # We approximate the intersecting volume between the
        # image simplex and the individual simplices by those
        # fractions.
        @views is = imsimplex_arrs[i]
        for k in 1:n_coeffs
            @! pt = transpose(convex_coeffs[k]) * transpose(is)
            innerloop!(idxs, signs, s_arr, Sj, pt, dim, M, i)
        end
    end
    # Need to normalise, because all we have up until now is counts
    # of how many points inside the image simplex falls into
    # the simplices.
    return transferoperator_triangulation_approx(transpose(M) ./ n_coeffs)
end


"""
Approximate the transfer operator for a set of points by triangulating them,
then compute approximate simplex intersections.
"""

function transferoperator_triangulation_approxNaive(invariant_pts;
        n_sample_pts::Int = 100, sample_randomly::Bool = true)
    original_pts = invariant_pts[1:end-1]
    forward_pts =  invariant_pts[2:end]

    DT = DelaunayTriangulation(invariant_pts[1:end-1])
    n_simplices = length(DT)
    dim = length(DT[1]) - 1

    # Collect all simplices and image simplices before the loop.
    # For all but the smallest triangulations, this is way faster
    # than gathering the points and creating new simplices at every
    # step of the loop.
    simplices = [Simplex(original_pts[DT[i]]) for i = 1:n_simplices]
    image_simplices = [Simplex(forward_pts[DT[i]]) for i = 1:n_simplices]

    #=
    Convex coefficients for computing interior points within the simplices.
    =#
    convex_coeffs = subsample_coeffs(dim, n_sample_pts, sample_randomly)

    #=
    # update number of points in case the subsampled points were generated
    # using a shape-preserving splitting of the parent simplex
    # (if so, because the number of subsimplices generated by the
    # shape-preserving splitting depends only on the dimension of the space,
    # there will be more points than we asked for). (If points are sampled
    # randomly, we will have exactly as many points within the simplex as
    # we asked for, and the number of points doesn't need to be adjusted)
    =#
    n_sample_pts = size(convex_coeffs, 2)

    @show n_sample_pts

    TO = zeros(Float64, n_simplices, n_simplices)

    interior_pt = zeros(Float64, 3)
    image_simplex_arr = zeros(Float64, dim, dim + 1)
    temp_simplex = MutableSimplex(zeros(Float64, dim, dim + 1))

    for j in 1:n_simplices
        image_simplex_arr[:, :] = image_simplices[j][:, :]

        for i in 1:n_simplices
            simplex = simplices[i]

            # Generate points within the simplex and check how many of them
            # lie inside the current image simplex.
            for k = 1:n_sample_pts
                @! interior_pt = image_simplex_arr * convex_coeffs[:, k]

                if point_contained!(temp_simplex, simplex, interior_pt)
                    TO[j, i] += 1.0
                end
            end
        end
    end

    return TransferOperatorTriangulationApprox(TO ./ n_sample_pts)
end
